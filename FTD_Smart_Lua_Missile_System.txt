--FTD Smart Missile Guidance System
--Author: 6dwavenminer
--Version: 1.4.0


--User Config Variables

--Launcher vehicle variables
MainFrameID = 0; --Which MainFrame to connect to
WeaponID = 0;
MaxDistanceBetweenLuaTranscieverAndMissileControl = 10; --The maximum distnace between a lua transciever and its corrisponding missile control block.

--Missile variables
TargetDetonationRange = -10; --If the distance between target and missile is below this value, blow up.

--Target acquisition variables
MaxRange = 4000; --Targets above this range from the missile launcher will be ignored.
MaxTargetHeight = 10000; --Targets above this height will be ignored.
MinTargetHeight = -20; --Targets below this range will be ignored.

--Safe detonation variables
SafeDetonteAltitude = 500; --If there are no target, goto and detonte at this altitude.

--Missile boost variables
BaseMissileThrust = 600; --Base thrust for missile.
MissileThrustTargetSpeedMultiplier = 10.0; --Value is multiplied by target's speed then added to base thrust of missile, useful for fast targets.
BoostIntecpetionTime = 7.0;	--When the intercept time falls below this value,'BoostThrust' is added to missile thrust, useful for Thumpers.
BoostThrust = 8000; --Value added to missile thrust once within boost range.

--Cruising variables
BaseDirectEngagementGroundRange = 240; --Below this ground range to target, head directly to target.
DirectEngagementGroundRangeSpeedMultipler = 0.6; --Added onto the engagment range after it has been multiplied by the target speed, used for fast targets.
CruisingAltitude = 250; --While en route travel at this altitude.
CruisingAltitudeAboveTerrain = 30; --If terrain nears cruising altitude, travel this heigh above the terrain.
MaxAllowedCruisingAltitude = 10000; --Missile will try and aviod going above this altitude
MinAllowedCruisingAltitude = 10; --Missile will try and aviod going below this altitude

--Anti ally collsion variables
AntiAlliedCollisionPredictionTimeLimit = 8; --Used to prevent missile-allied vessel collisions, number is seconds into the future predicted.
AntiAlliedCollisionPredictionTimeStep = 1; --The time step in seconds used to prevent missile-allied vessel collisions.
AntiAlliedCollisionAdditionalSafetyRange = 5; --Additional range to border of allies to avoid.

--End of User Config Variables

--Global Variables
TargetVelocityArray = {};
PreviousTimeForTargets = 0;
MissileVelocityArray = {};
PreviousTimeForMissiles = 0;
UseableLuaTransceiverList = {};
UseableLuaTransceiverCount = 0;
TickCount = 0;

function GetUseableLuaTranscivers(I)
 local MissileLauncherPos = I:GetWeaponInfo(WeaponID).GlobalPosition;
 local t;
 UseableLuaTransceiverCount = 0;
 for t=0, I:GetLuaTransceiverCount()-1 do
  if Vector3.Distance(MissileLauncherPos,I:GetLuaTransceiverInfo(t).Position) < MaxDistanceBetweenLuaTranscieverAndMissileControl then
   UseableLuaTransceiverList[UseableLuaTransceiverCount] = t;
   UseableLuaTransceiverCount = UseableLuaTransceiverCount + 1;
  end
 end
end

--Check that the WeaponID corrisponds to a missile launcher
function WeaponsCheck(I)
 if I:GetWeaponInfo(WeaponID).Valid == false then
  I:LogToHud("Invalid WeaponID, change WeaponID in LUA code"); 
 else
  if I:GetWeaponInfo(WeaponID).WeaponType == 4 then --Turret check
   if not I:GetWeaponInfoOnTurretOrSpinner(WeaponID, 0).WeaponType == 5 then --Weapons check, is it a missile launcher?
    I:LogToHud("Weapon is not missile launcher, change WeaponID in LUA code, note this weapon is on a turret or spinner,further debugging maybe required"); 
   else
    GetUseableLuaTranscivers(I);
   end
  else
   if not I:GetWeaponInfo(WeaponID).WeaponType == 5 then --Weapons check, is it a missile launcher?
    I:LogToHud("Weapon is not missile launcher, change WeaponID in LUA code"); 
   else
    GetUseableLuaTranscivers(I);
   end
  end
 end
end

--Creates a list of all targets within range
function GenerateTargetList(I)
 local OutputBuffer = {};
 local TargetIDList = {};
 local NumTargets = 0;
 local TargetPos;
 local TargetRange;
 local n;
 for n=0,I:GetNumberOfTargets(MainFrameID)-1 do
  TargetPos = I:GetTargetInfo(MainFrameID,n).AimPointPosition;
  TargetRange = Vector3.Distance(I:GetWeaponInfo(WeaponID).GlobalPosition,TargetPos);
  if (TargetRange < MaxRange) and (TargetPos.y < MaxTargetHeight) and (TargetPos.y > MinTargetHeight) then
   TargetIDList[NumTargets] = n;
   NumTargets = NumTargets + 1;
  end
 end
 OutputBuffer[0] = NumTargets;
 for n=1, NumTargets do
  OutputBuffer[n] = TargetIDList[n -1];
 end
 return OutputBuffer;
end

--If theres no targets go up to safe distance to detonte the missle
function NoTargetSafelyDetonte(I)
 local i;
 local t;
 local m;
 local Missile;
 local MissilePos;
 local MissileSpeed;
 for i=0, UseableLuaTransceiverCount-1 do
  local t = UseableLuaTransceiverList[i];
  for m=0, I:GetLuaControlledMissileCount(t)-1 do
   Missile = I:GetLuaControlledMissileInfo(t,m);
   MissilePos = Missile.Position;
   MissileSpeed = Vector3.Magnitude(Missile.Velocity);
   AimPoint = Vector3(MissilePos.x,SafeDetonteAltitude + 10,MissilePos.z);
   AimPoint = AllyCollisionAviodance(I,MissileSpeed,MissilePos,AimPoint);
   I:SetLuaControlledMissileAimPoint(t,m,AimPoint.x, AimPoint.y, AimPoint.z);
   if ((MissilePos.y > SafeDetonteAltitude) and (SafeDetonteAltitude > 0)) or ((MissilePos.y < SafeDetonteAltitude) and (SafeDetonteAltitude <= 0)) then
    I:DetonateLuaControlledMissile(t,m);
   end
  end
 end
end

function CountActiveMissiles(I)
 local NumMissiles = 0;
 local i;
 local t;
 local m;
 for i=0, UseableLuaTransceiverCount-1 do
 local t=UseableLuaTransceiverList[i];
  for m=0, I:GetLuaControlledMissileCount(t)-1 do
   NumMissiles = NumMissiles + 1;
  end
 end
 return NumMissiles;
end

--Calculate acceleration of active missiles
function CalculateAccelerationOfMissiles(I,MissileVelocity,MissileID)
 local PreviousMissileVelocity = MissileVelocityArray[MissileID];
 local MissileAcceleration;
 if PreviousMissileVelocity ~= nil then
  MissileAcceleration = (MissileVelocity - PreviousMissileVelocity) / (I:GetTime() - PreviousTimeForMissiles);
 else
  MissileAcceleration = Vector3(0,0,0);
 end
 MissileVelocityArray[MissileID] = MissileVelocity;
 PreviousTimeForMissiles = I:GetTime() 
 return MissileAcceleration;
end

function CalculateEnemyFleetScore(I,NumTargets,TargetIDList)
 --Find lowest enemy score
 local EnemyFleetTotalScore = 0;
 local LowestScore = 100000;
 local ScoreOffset;
 local n;
 for n=0, NumTargets-1, 1 do
  if (I:GetTargetInfo(MainFrameID,TargetIDList[n]).Score) < LowestScore then
   LowestScore = I:GetTargetInfo(MainFrameID,TargetIDList[n]).Score;
  end
 end
 
 --Calculate score offset
 ScoreOffset = -100000;
 for n=0, NumTargets-1, 1 do
  if (I:GetTargetInfo(MainFrameID,TargetIDList[n]).Score) > ScoreOffset then
   ScoreOffset = I:GetTargetInfo(MainFrameID,TargetIDList[n]).Score;
  end
 end
 ScoreOffset = ScoreOffset / 2;
 ScoreOffset = ScoreOffset - LowestScore;

 --Calculate enemy fleet score
 for n=0, NumTargets-1, 1 do
  EnemyFleetTotalScore = EnemyFleetTotalScore + I:GetTargetInfo(MainFrameID,TargetIDList[n]).Score + ScoreOffset;
 end
 return EnemyFleetTotalScore,ScoreOffset;
end


--Calculate how many to missiles each target
function CalculateMissilesPerTarget(I,NumTargets,TargetIDList,NumMissiles,EnemyFleetTotalScore,ScoreOffset)
 local MissilesPerTarget = {};
 local n;
 for n=0, NumTargets-1, 1 do
  if NumTargets == 1 then
   MissilesPerTarget[n] = NumMissiles;
  else
   MissilesPerTarget[n] = ((I:GetTargetInfo(MainFrameID,TargetIDList[n]).Score + ScoreOffset) / EnemyFleetTotalScore) * NumMissiles;
   MissilesPerTarget[n] = math.floor(MissilesPerTarget[n] + 0.5);
  end
 end
 return MissilesPerTarget;
end

 --Calculate acceleration of enemy targets
function CalculateAccelerationOfTargets(I,NumTargets,TargetIDList)
 local TargetAcceleration = {};
 local Target;
 local n;
 for n=0, NumTargets-1 do
  Target = I:GetTargetInfo(MainFrameID,TargetIDList[n]);
  if TargetVelocityArray[TargetIDList[n]] ~= nil then
   TargetAcceleration[n] = (Target.Velocity - TargetVelocityArray[TargetIDList[n]]) / (I:GetTime() - PreviousTimeForTargets);
   TargetVelocityArray[TargetIDList[n]] = Target.Velocity;
  else 
   TargetAcceleration[n] = Vector3(0,0,0);
  end
 end
 PreviousTimeForTargets = I:GetTime() 
 return TargetAcceleration;
end

function AssignTargetForMissile(I,NumTargets,TargetNum,MissileNum,MissilesPerTarget)
 --Increment MissileID
 MissileNum = MissileNum + 1;
 if MissileNum > MissilesPerTarget[TargetNum] then
  if TargetNum < NumTargets - 1 then 
   TargetNum = TargetNum + 1;
   MissileNum = 0;
  end
 end
 return TargetNum,MissileNum
end

--Calculate distance ignoring vertical component
function CalculateGroundDistanceToTarget(I,MissilePos,TargetPos)
  local GroundDistanceToTarget;
  local TwoDMissilePos = MissilePos * 1; --Multiply by one to only copy the data, not the reference!
  local TwoDTargetPos = TargetPos * 1; --Multiply by one to only copy the data, not the reference!
  TwoDMissilePos.y = 0;
  TwoDTargetPos.y = 0;
  GroundDistanceToTarget = Vector3.Distance(TwoDMissilePos,TwoDTargetPos);
  return GroundDistanceToTarget;
end

--En route go to attlitude till near target
function TravelTowardsTarget(I,MissileHeightAboveTerrain,MissilePos,TargetPos)
	local CruisingHeight = CruisingAltitude;
	if MissileHeightAboveTerrain > CruisingAltitude - 20 then
		CruisingHeight = MissileHeightAboveTerrain + CruisingAltitudeAboveTerrain;
	end
	--Now head to target
	local GroundDistanceToTarget = CalculateGroundDistanceToTarget(I,MissilePos,TargetPos);		if GroundDistanceToTarget < BaseMissileThrust / 15 then
		AimPoint = Vector3(TargetPos.x, CruisingHeight, TargetPos.z);
	else
		--Correct overshooting of height
		local CoOrdinateMultiplier = (BaseMissileThrust / 15) / GroundDistanceToTarget;
		local Missle_TargetDifferentialPosX = MissilePos.x - TargetPos.x;
		local Missle_TargetDifferentialPosZ = MissilePos.z - TargetPos.z;
		AimPoint = Vector3(MissilePos.x - (Missle_TargetDifferentialPosX * CoOrdinateMultiplier), CruisingHeight, MissilePos.z - (Missle_TargetDifferentialPosZ * CoOrdinateMultiplier));
	end
	return AimPoint;
end


--Changes the missile thrust every 20 ticks
function SetMissileThrust(I,t,m,Thrust)
	if TickCount < 20 then
		TickCount = TickCount + 1;
	else
		TickCount = 0;
		local Missile = I:GetLuaControlledMissileInfo(t, m);
		if Missile.Valid == true then
			local MissileInfo = I:GetMissileInfo(t,m);--Lagfest
			if (MissileInfo ~= nil) then
				for i,part in pairs(MissileInfo.Parts) do
					if (string.find(part.Name, 'variable')) then
						MissileInfo.Parts[i]:SendRegister(2, Thrust);
					end
				end
			end
		end
	end
end

function ControlMissileThrust(I,t,m,IntecpetionTime,TargetSpeed)
	local MissileThrust = BaseMissileThrust + (TargetSpeed * MissileThrustTargetSpeedMultiplier);
	if IntecpetionTime < BoostIntecpetionTime then
		MissileThrust = MissileThrust + BoostThrust;
	end
	SetMissileThrust(I,t,m,MissileThrust);
end


function PredictInterceptPosition(I,t,m,MissilePos,TargetPos,MissileSpeed,MissileAcceleration,TargetSpeed,TargetVelocity,TargetAcceleration,IntecpetionTime)
 local IntecpetionRange;
 local InterceptionAimPos;
 local Range = Vector3.Distance(MissilePos,TargetPos);
 local MinInterceptionTime = Range / (MissileSpeed + TargetSpeed);
 local InterceptionAimPos = TargetPos + (TargetVelocity * MinInterceptionTime) + ((TargetAcceleration + MissileAcceleration) * 0.5 * math.pow(MinInterceptionTime,2));
 for i=0, 12 do
  IntecpetionRange = Vector3.Distance(MissilePos,InterceptionAimPos);
  IntecpetionTime = IntecpetionRange / MissileSpeed;
  InterceptionAimPos = TargetPos + (TargetVelocity * IntecpetionTime) + ((TargetAcceleration + MissileAcceleration) * 0.5 * math.pow(IntecpetionTime,2));
 end 

 AimPoint = Vector3(InterceptionAimPos.x,InterceptionAimPos.y,InterceptionAimPos.z);
 return AimPoint,IntecpetionTime;
end

--Checks missiles curret appoximate trajectory for any possible collisions with predicted allied postions and attempts to aviod them
function AllyCollisionAviodance(I,MissileSpeed,MissilePos,AimPoint)
 --Find all possible allied collsions
 local n;
 local t;
 local MissileTimeToReachAimPos;
 local MissileFuturePos;
 local FutureAllyReferencePosition;
 local FutureAllyReferencePositionPositiveSize;
 local FutureAllyReferencePositionNegativeSize;
 local PositiveAviodCoOrdinates;
 local NegativeAviodCoOrdinates;
 local MissileFutureCollisionPos;
 local PositiveEvadeDistance;
 local NegativeEvadeDistance;
 local AlliedCollsionTimeArray = {};
 local AlliedCollsionFriendlyIndexArray = {};
 local NearestTimeCollsion = AntiAlliedCollisionPredictionTimeLimit;
 local NumOfPossibleAlliedCollision = 0;
 local NumOfFriendlies = I:GetFriendlyCount();
 local FriendlyInfo;
 for n=0, NumOfFriendlies-1 do
  FriendlyInfo = I:GetFriendlyInfo(n);
  if FriendlyInfo.Valid == true then
   MissileTimeToReachAimPos = Vector3.Distance(MissilePos,AimPoint) / MissileSpeed;
   for t=0, AntiAlliedCollisionPredictionTimeLimit-1,AntiAlliedCollisionPredictionTimeStep do
    if MissileTimeToReachAimPos > t then --Don't care is the ally is behind the enemy target
     MissileFuturePos = MissilePos + ((AimPoint - MissilePos) / t); 
	 FutureAllyReferencePosition = FriendlyInfo.ReferencePosition + (FriendlyInfo.Velocity * t);
     FutureAllyReferencePositionPositiveSize = FutureAllyReferencePosition + FriendlyInfo.PositiveSize + Vector3(AntiAlliedCollisionAdditionalSafetyRange,AntiAlliedCollisionAdditionalSafetyRange,AntiAlliedCollisionAdditionalSafetyRange);
     FutureAllyReferencePositionNegativeSize = FutureAllyReferencePosition + FriendlyInfo.NegativeSize - Vector3(AntiAlliedCollisionAdditionalSafetyRange,AntiAlliedCollisionAdditionalSafetyRange,AntiAlliedCollisionAdditionalSafetyRange);
	 if  (MissileFuturePos.x <= FutureAllyReferencePositionPositiveSize.x)
	 and (MissileFuturePos.x >= FutureAllyReferencePositionNegativeSize.x)
	 and (MissileFuturePos.y <= FutureAllyReferencePositionPositiveSize.y)
	 and (MissileFuturePos.y >= FutureAllyReferencePositionNegativeSize.y)
     and (MissileFuturePos.z <= FutureAllyReferencePositionPositiveSize.z)
 	 and (MissileFuturePos.z >= FutureAllyReferencePositionNegativeSize.z)
	 then
	  --Will probably collide with ally, record time and friendly Index
	  if t < NearestTimeCollsion then
	   NearestTimeCollsion = t;
	  end
	  AlliedCollsionTimeArray[0] = t;
	  AlliedCollsionFriendlyIndexArray[0] = n;
	  NumOfPossibleAlliedCollision = NumOfPossibleAlliedCollision + 1;
	  break
     end
    end
   end
  end
 end

 --Calculate where the missile can't go 
 PositiveAviodCoOrdinates = Vector3(-100000,100000,-100000);
 NegativeAviodCoOrdinates = Vector3(100000,100000,100000);
 for n=0, NumOfPossibleAlliedCollision-1 do
  t = AlliedCollsionTimeArray[n];
  if NearestTimeCollsion == t then --Only care about the nearest time possible collsions
   FriendlyInfo = I:GetFriendlyInfo(n);
  
   FutureAllyReferencePosition = FriendlyInfo.ReferencePosition + (FriendlyInfo.Velocity * t);
   FutureAllyReferencePositionPositiveSize = FutureAllyReferencePosition + FriendlyInfo.PositiveSize + Vector3(AntiAlliedCollisionAdditionalSafetyRange,AntiAlliedCollisionAdditionalSafetyRange,AntiAlliedCollisionAdditionalSafetyRange);
   FutureAllyReferencePositionNegativeSize = FutureAllyReferencePosition + FriendlyInfo.NegativeSize - Vector3(AntiAlliedCollisionAdditionalSafetyRange,AntiAlliedCollisionAdditionalSafetyRange,AntiAlliedCollisionAdditionalSafetyRange);
  
   if (PositiveAviodCoOrdinates.x <= FutureAllyReferencePositionPositiveSize.x) then
    PositiveAviodCoOrdinates.x = FutureAllyReferencePositionPositiveSize.x;
   end
   if (NegativeAviodCoOrdinates.x >= FutureAllyReferencePositionPositiveSize.x) then
    NegativeAviodCoOrdinates.x = FutureAllyReferencePositionNegativeSize.x;
   end
   if (PositiveAviodCoOrdinates.y <= FutureAllyReferencePositionPositiveSize.y) then
    PositiveAviodCoOrdinates.y = FutureAllyReferencePositionPositiveSize.y;
   end
   if (NegativeAviodCoOrdinates.y >= FutureAllyReferencePositionPositiveSize.y) then
    NegativeAviodCoOrdinates.y = FutureAllyReferencePositionNegativeSize.y;
   end
   if (PositiveAviodCoOrdinates.z <= FutureAllyReferencePositionPositiveSize.z) then
    PositiveAviodCoOrdinates.z = FutureAllyReferencePositionPositiveSize.z;
   end
   if (NegativeAviodCoOrdinates.z >= FutureAllyReferencePositionPositiveSize.z) then
    NegativeAviodCoOrdinates.z = FutureAllyReferencePositionNegativeSize.z;
   end
  end
 end

 --Find the nearest non-collsion point while trying to maintain route to target
 if NumOfPossibleAlliedCollision > 0 then
  MissileFutureCollisionPos = MissilePos + ((AimPoint - MissilePos) / NearestTimeCollsion); 
  PositiveEvadeDistance = Vector3.Magnitude(MissileFutureCollisionPos - PositiveAviodCoOrdinates);
  NegativeEvadeDistance = Vector3.Magnitude(MissileFutureCollisionPos - NegativeAviodCoOrdinates);
  --Now we try and steer the missile away from the possible collisions
  if PositiveEvadeDistance < NegativeEvadeDistance  then
   AimPoint = PositiveAviodCoOrdinates;
   if PositiveEvadeDistance.y > MaxAllowedCruisingAltitude then
    AimPoint.y = MaxAllowedCruisingAltitude.y;
   end
  else
   AimPoint = NegativeAviodCoOrdinates;
   if NegativeAviodCoOrdinates.y < MinAllowedCruisingAltitude then
    AimPoint.y = MinAllowedCruisingAltitude;
   else
   end
  end
 end
 return AimPoint;
end

--Main
function Update(I)
--Startup
WeaponsCheck(I);
local TargetListBuffer = {};
local TargetIDList = {};
local TargetListBuffer = unpack{GenerateTargetList(I)};
local TargetAcceleration = {};
local NumTargets = TargetListBuffer[0];

local NumMissiles = 0;
local EnemyFleetTotalScore = 0;
local MissilesPerTarget = {};
local ScoreOffset = 0;

local MissileNum = 0;
local MissileID = 0;
local TargetNum = 0;

local Target;
local TargetPos;
local TargetVelocity;
local TargetSpeed;
   
local Missile;
local MissilePos;
local MissileVelocity;
local MissileSpeed;
local MissileAcceleration;
local MissileHeightAboveTerrain;

--Counter variables
local n;
local i;
local t;
local m;


if NumTargets > 0 then
 for n=0, NumTargets-1 do
  TargetIDList[n] = TargetListBuffer[n+1];
 end 
end      

if NumTargets<=0 then
 NoTargetSafelyDetonte(I);
else
 NumMissiles = CountActiveMissiles(I);
 EnemyFleetTotalScore,ScoreOffset = unpack{CalculateEnemyFleetScore(I,NumTargets,TargetIDList)};
 MissilesPerTarget = CalculateMissilesPerTarget(I,NumTargets,TargetIDList,NumMissiles,EnemyFleetTotalScore,ScoreOffset);
 
 TargetAcceleration = CalculateAccelerationOfTargets(I,NumTargets,TargetIDList);
 
  for i=0, UseableLuaTransceiverCount-1 do
   t=UseableLuaTransceiverList[i];
   for m=0, I:GetLuaControlledMissileCount(t)-1 do
    TargetNum,MissileNum = unpack{AssignTargetForMissile(I,NumTargets,TargetNum,MissileNum,MissilesPerTarget)};
    local Target = I:GetTargetInfo(MainFrameID,TargetIDList[TargetNum]);
    local TargetPos = Target.AimPointPosition;
    local TargetVelocity = Target.Velocity;
    local TargetSpeed = Vector3.Magnitude(TargetVelocity);
   
    local Missile = I:GetLuaControlledMissileInfo(t,m);
    local MissilePos = Missile.Position;
	local MissileVelocity = Missile.Velocity;
    local MissileSpeed = Vector3.Magnitude(MissileVelocity);
	MissileID = MissileID + 1;
	local MissileAcceleration = CalculateAccelerationOfMissiles(I,MissileVelocity,MissileID);
	MissileAcceleration = Vector3(0,0,0);
    local MissileHeightAboveTerrain = I:GetTerrainAltitudeForPosition(MissilePos);
	
	if Vector3.Distance(MissilePos,TargetPos) < TargetDetonationRange then
	 I:DetonateLuaControlledMissile(t,m);
	end
	
    if MissileHeightAboveTerrain < 0 then 
     MissileHeightAboveTerrain = 0;
    end 
    GroundDistanceToTarget = CalculateGroundDistanceToTarget(I,MissilePos,TargetPos);
    if GroundDistanceToTarget > BaseDirectEngagementGroundRange + (DirectEngagementGroundRangeSpeedMultipler * TargetSpeed) then
     AimPoint = TravelTowardsTarget(I,MissileHeightAboveTerrain,MissilePos,TargetPos);
	 --Set missle thrust
	ControlMissileThrust(I,t,m,500,TargetSpeed);
    else
	local IntecpetionTime = 0;
     AimPoint,IntecpetionTime = unpack{PredictInterceptPosition(I,t,m,MissilePos,TargetPos,MissileSpeed,MissileAcceleration,TargetSpeed,TargetVelocity,TargetAcceleration[TargetIDList[TargetNum]])};
	 --Set missle 
	ControlMissileThrust(I,t,m,IntecpetionTime,TargetSpeed);
    end
	--Check to make sure we don't blow up any allies
	AimPoint = AllyCollisionAviodance(I,MissileSpeed,MissilePos,AimPoint);
	--Now aim at target
	I:SetLuaControlledMissileAimPoint(t,m,AimPoint.x,AimPoint.y,AimPoint.z);
   end
  end
 end
end
 
 

